package pl.pateman.entitygenerator;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import pl.pateman.entitygenerator.GeneratedEntity.Attribute;
import pl.pateman.entitygenerator.exception.SourceFileGeneratorException;
import pl.pateman.entitygenerator.generate.Generator;

/**
 * A class responsible for taking a {@link GeneratedEntity} and passing it to the provided {@link Generator} to convert
 * it to source code.
 */
public final class SourceFileGenerator {

  private final Generator generator;

  public SourceFileGenerator(final Generator generator) {
    this.generator = generator;
    if (this.generator == null) {
      throw new IllegalArgumentException("A valid generator is required");
    }
  }

  /**
   * Generates a shortened import name from the given fully qualified class name.
   *
   * Example:
   *  java.util.List<pl.pateman.entities.UserEntity> is transformed into List<UserEntity>
   *  java.lang.String is transformed into String
   *
   * @param fullName Fully qualified class name.
   * @return Shortened class name.
   */
  private String getShortenedImportName(final String fullName) {
    //  Check if there's a diamond operator in the name. If so, we're dealing with a generic type, so we need
    //  to shorten the name a bit differently.
    final int openingDiamondIndex = fullName.indexOf('<');
    if (openingDiamondIndex != -1) {
      //  Start by extracting the generic class' name.
      final String beforeOpeningDiamond = fullName.substring(0, openingDiamondIndex);
      final String actualType = beforeOpeningDiamond.substring(beforeOpeningDiamond.lastIndexOf('.') + 1);

      //  Extract the classes between diamonds.
      final String fullGenericType = fullName.substring(openingDiamondIndex + 1, fullName.indexOf('>'));

      //  Split the classes found between diamonds, and shorten them.
      final String genericType = Arrays
          .stream(fullGenericType.split(","))
          .map(x -> x.substring(x.lastIndexOf('.') + 1))
          .collect(Collectors.joining(", "));
      return actualType + "<" + genericType + ">";
    } else {
      //  No diamond operator found, so we just need to take the last part of the fully qualified name.
      return fullName.substring(fullName.lastIndexOf('.') + 1);
    }
  }

  /**
   * Takes the given entity and prepares a {@link Map} of imports referenced by it.
   *
   * Keys of the returned map store fully qualified class names of referenced classes, and values hold shortened names
   * which can be used, for example, for field declarations. Shortened names are generated by
   * {@link SourceFileGenerator#getShortenedImportName(String)}.
   *
   * @param generatedEntity Entity which should be used for generating imports.
   * @return A {@link Map} of imports which the entity references.
   */
  private Map<String, String> prepareImports(final GeneratedEntity generatedEntity) {
    final Set<String> attributeTypes = generatedEntity
        .getAttributes()
        .stream()
        .map(Attribute::getType)
        .sorted()
        .collect(Collectors.toCollection(LinkedHashSet::new));

    if (attributeTypes.isEmpty()) {
      return Collections.emptyMap();
    }

    final Map<String, String> importsMap = new LinkedHashMap<>();
    attributeTypes.forEach(type -> importsMap.put(type, this.getShortenedImportName(type)));
    return importsMap;
  }

  /**
   * Generates source code for the provided entity.
   *
   * @param generatedEntity Entity to generate source code for.
   * @return Source code.
   */
  public String generateSourceFile(final GeneratedEntity generatedEntity) {
    if (generatedEntity == null) {
      throw new IllegalArgumentException("A valid entity is required");
    }

    //  Prepare parameters.
    final Map<String, Object> params = new HashMap<>();
    params.put("entity", generatedEntity);
    params.put("packageName",
        generatedEntity.getClassFile().substring(0, generatedEntity.getClassFile().lastIndexOf('.')));
    params.put("imports", this.prepareImports(generatedEntity));

    //  Pass the entity and computed parameters to the provided generator.
    try {
      return this.generator.generateSource(generatedEntity, params);
    } catch (final Exception e) {
      throw new SourceFileGeneratorException("Unable to generate source code for this entity", e);
    }
  }
}
